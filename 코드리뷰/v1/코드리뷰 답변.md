- 어노테이션 사이 공백 및 순서 변경
- 공백 라인 삭제
- 중괄호 줄바꿈
- 변수명 List -> 복수 표현 변경 (scenarioList -> scenarios)
- entity setter -> method 변경
- entity nullable및 size 제약조건 수정
- request Enum 상수 소문자 반환 가능 (response에서는 대문자)
- 매개변수 final 선언
- dto POJO -> record 변경

### Entity 필드에 백틱이 들어갔던 이유
hour, order등 h2의 예약어와 겹쳐서 백틱으로 사용했는데, 예약어와 겹치지 않게 필드명 변경했습니다.

### Notif 축약 표현 -> Notification 변경
처음에 Notif를 사용한 이유는 실제 회사에서 축약표현을 많이 사용한다고 해서 사용했는데요. 말씀하신대로 공통화가 되지 못한 문제가 있었던 거 같아요. noti로 변경을 고려하였지만 entity, 필드명, 클래스명, dto필드명 등등 축약 표현을 사용하는것에 경계가 애매해질 거 같아서 notificaiton 풀네임으로 변경했습니다.

### @Transactional(readOnly = true) 클래스에 선언
클래스 자체에 선언하는 경우는 클래스의 대부분이 읽기 전용일때만 추천하는 걸로 알고 있습니다. CURD의 전체를 다루는 기본 service이기 때문에 읽기 전용인 메서드에만 선택적으로 부여하는 방식이 더 올바른 방식인 거 같아요!

### Scenario Update 로직 설명
저희 서비스를 보시면 아시겠지만 시나리오를 생성하는 form과 수정하는 form이 같습니다. 때문에 수정 시, 만약 사용자가 시나리오의 메모만 변경한다 하더라도 전체 form을 가져와서 업데이트 트랙젝션을 실행해야하는데요. 변경사항이 있는 데이터만 최소한으로 db에 접근하고자 해서 업데이트 해야하는 목록을 비교하는 로직 때문에 복잡해진 거 같아요.

updateNotification 로직을 예로 들어서 설명해드릴게요.

만약 사용자가 시간 타입 알림을 월, 화, 수 9:30분으로 등록한다면:
- Notification은 시간 타입, 알림 메서드, 알림 활성화 여부를 저장하게 되고
- 시간이기 때문에 notification_id를 FK로 갖는 TimeNotification 데이터가 추가되게 됩니다.
여기서 각 타입에 맞는 알림condition(TIME, LOCATION) 서비스 분기 처리를 해주는 로직이 Selector입니다.

Notification은 다름과 같이 저장됩니다:
```
{
  "id": 1,
  "isActive": true,
  "notificationType": "TIME",
  "notificationMethodType": "PUSH",
  ...
}
```
TimeNotification은 다음과 같이 저장됩니다:
- (pk. 1) 월-9:30
- (pk. 2) 화-9:30
- (pk. 3) 수-9:30
```
[
  {
    "id": 1,
    "notification": {
      "id": 1
    },
    "dayOfWeek": "MONDAY",    // ordinal: 0
    "startHour": 9,
    "startMinute": 30,
    ...
  },
  {
    "id": 2,
    "notification": {
      "id": 1
    },
    "dayOfWeek": "TUESDAY",   // ordinal: 1
    "startHour": 9,
    "startMinute": 30,
    ...
  },
  {
    "id": 3,
    "notification": {
      "id": 1
    },
    "dayOfWeek": "WEDNESDAY", // ordinal: 2
    "startHour": 9,
    "startMinute": 30,
    ...
  }
]
```

만약에 사용자가 업데이트를 아래와 같이 했을 경우 처리 과정입니다.

변경 내용: 월 화 목 금 10:00

처리 과정:
- 알림 조건만 업데이트(시간): 월요일, 화요일
- 삭제: 수요일
- 새롭게 추가: 목요일, 금요일

결과(TimeNotification):
- (pk. 1) 월-10:00
- (pk. 2) 화-10:00
- (pk. 4) 목-10:00
- (pk. 5) 금-10:00

만약 알림 활성을 false로 할 경우는 Notification의 값만 있으며, TimeNotification의 데이터는 삭제됩니다.
```
{
  "id": 1,
  "isActive": false,
  "notificationType": "TIME",
  "notificationMethodType": "null",
  ...
}
```

#### 왜 요일에 따라서 row를 생성하는가?
처음에는 요일 테이블을 따로 두려고 했습니다. 알림 시간이 요일 수만큼 중복되지 않아도 되며, 수정하는 부분에서 더 수월하다고 생각했습니다.
근데 문제는 알림 실행 로직을 구현하면서 요일 테이블까지 추가하게 되면 조회부분에서 성능이 많이 저하될 거라고 생각했습니다. 중복이 되는 데이터도 일주일 최대 7일로 무겁지 않은 양이라고 생각했습니다.

그래서 알림을 찾을 때:
- 요일
- 시간
- 분
- 사용자 푸시 알림 여부

를 판단하게 되는데 (요일-시간-분)이 만약에 같은 테이블 안에 있을 경우에는 인덱스를 설정하여 더 빨리 조회할 수 있을 거라고 생각했습니다.

정리하자면 알림 처리를 위해 요일당 row로 저장했습니다.


### 생성 및 업데이트 후 결과 반환
- TODAY 미션 추가했을 경우 → 추가한 미션 반환
- 시나리오 순서를 변경했을 시 → order 값 반환
- 시나리오를 추가했을 경우 → 추가된 시나리오 ID 반환
- 시나리오를 수정했을 경우 → void

시나리오를 추가하고 수정한 뒤에는 home으로 이동합니다. Home으로 이동하면 다시 생성하고 수정한 시나리오 ID로 재조회해야 한다고 생각했습니다.

추가했을 경우의 새로운 시나리오 ID로 바로 조회하면 되고, 수정은 이미 그 시나리오의 ID를 알고 있기 때문에 바로 MissionGroupResponse를 받아서 정적으로 다시 조회하는 게 클라이언트에서도 깔끔하다고 생각했습니다.