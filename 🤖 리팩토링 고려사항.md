캐시 저장 방식 spring -> redis 저장
시나리오, 미션 목록 조회 캐시

미션 조회 캐시
```
@Cacheable(value = "missions", key = "#scenarioId + ':' + #date")
public MissionGroupResponse getMissions(Long scenarioId, LocalDate date) {
    return missionQueryService.findMissionsByScenarioId(scenarioId, date);
}

@CacheEvict(value = "missions", key = "#scenarioId")
public void updateScenario(Long scenarioId, ScenarioUpdateRequest request) {
    scenarioService.update(scenarioId, request);
}

@CacheEvict(value = "missions", key = "#scenarioId")
public void deleteScenario(Long scenarioId) {
    scenarioService.delete(scenarioId);
}

@CacheEvict(value = "missions", key = "#scenarioId")
public void addMission(Long scenarioId, MissionRequest request) {
    missionService.add(scenarioId, request);
}
```

```
implementation 'org.springframework.boot:spring-boot-starter-data-redis'
```


```
@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(1)) // TTL 설정
            .disableCachingNullValues();

        return RedisCacheManager.builder(connectionFactory)
            .cacheDefaults(config)
            .build();
    }
}
```



- 미션 업데이트시 미래백업 미션 사항

- 알림 업데이트 kafka 사용
- 
- **날씨 데이터** → 여러 소비자가 동시에 활용해야 하므로 Kafka 적합
    
- **시나리오 백업/로그 적재** → Kafka 적합

- 데드락

- 캐시 무효화 : SCAN 사용 - 알림




Hibernate 6에서는 `FETCH JOIN` + `WHERE` 조건이 들어가면 엔티티 그래프가 **정상적인 영속 엔티티 트리로 관리되지 못하고, 일종의 projection 결과처럼 취급**되는 경우가 있음.