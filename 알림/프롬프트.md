구현 방식은 Write-through 방식

redis에 저장은 크게 2타입
1. 시나리오 알림 저장 - Hsah
2. Etag 저장 - String

- notif+사용자id : Fields(시나리오id - 시나리오, 알림 정보)
```
Key: notif:42
Type: Hash
Fields:
   201 -> '{ "scenarioId": 201, "scenarioName": "아침 루틴",
              "notification": { "id": 101, "type": "TIME", "isActive": true,
                                "conditions": [{ "hour": 7, "minute": 30 }] } }'

   202 -> '{ "scenarioId": 202, "scenarioName": "출근 준비",
              "notification": { "id": 102, "type": "LOCATION", "isActive": true,
                                "conditions": [{ "lat": 37.55, "lon": 127.01 }] } }'
```

- Etag 저장
- Key = 사용자 단위 (`notif:etag:{memberId}`) 
- Value = ETag 값 (updatedAt)


트래킹은 아래와 같음
- 알림이 있는 시나리오 생성 - 추가
- 알림이 있는 시나리오 수정 - 삭제후 추가(교체)
- 알림 없는 시나리오 수정 - 삭제
- 시나리오 삭제 - 삭제

트리거해서 바로 redis에 업데이트
이때 TTL은 한달
새롭게 업데이트 될때마다 EXPIRE 호출해서 TTL 갱신
Etag updatedAt 업데이트

클라이언트에서는 처음 화면에 진입할때, 시나리오생성, 수정, 삭제시 api를 호출할것임
member_id + 가지고있는 Etag
를 보내는데
만약 Etag가 같다면 변경사항 없음으로 보냄
Etag가 다르다면 변경사항 있음으로 갱신된 목록을 보냄

1. 클라이언트가 화면 진입시 요청
2. 캐시 미스
3. db에서 읽어오고 캐시 저장
4. 반환
5. 시나리오 추가, 수정, 삭제시 캐시 업데이트
6. 클라이언트 요청
7. Etag 확인
8. 처리



- CacheDto는 따로 생성할것

시나리오 아이디당
- 시나리오 이름
- 시나리오 메모
- 시나리오 순서
	- 알림 ID
	- TimeNotification이나 LocationNotification 정보
여기서 TimeNotification, LocationNotification은 데이터가 다른데, 조건을 그냥 json으로 직렬화해서 저장
- Redis에는 단순한 **Cache DTO** 저장
    
`public record NotificationCacheDto(     Long scenarioId,     String scenarioName,     NotificationType notificationType,     String conditionJson // Time/Location 조건을 그냥 JSON으로 직렬화 ) {}`

- 꺼낼 때:
    - `conditionJson`을 `NotificationType`에 따라 파싱해서
    - `NotificationConditionResponse` (TimeNotificationResponse, LocationNotificationResponse)로 변환해서 응답


추가 요구 사항
2. **동기화 실패 대비**
    - 만약 DB update는 성공했는데 Redis update는 실패하면?
    - 그럴 땐 Redis 캐시 날려라
    - 클라이언트에서 요청이 오면 db 조회
    - 즉, 실패 시 `DEL notif:{memberId}` 전략도 고려
        