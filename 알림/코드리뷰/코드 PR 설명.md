## API 구조

API는 크게 2개입니다.
1. 전체 조회 (`GET /scenarios`)
    - 클라이언트가 If-None-Match 헤더에 ETag를 담아 요청.
    - 서버 Redis에 저장된 ETag와 비교 → 같으면 304(Not Modified), 다르면 최신 목록을 반환.
    - 클라이언트는 반환된 ETag를 계속 보관하여 이후 요청에 사용.
    - 즉, 304 응답은 클라이언트가 알림 목록을 갱신하지 않아도 됨을 의미.
      
    ETag는 Redis 업데이트 시점(밀리초 타임스탬프)으로 관리됩니다.  
    따라서 Redis 갱신이 발생하면 자동으로 ETag도 변경되어, 최신 여부 비교가 가능합니다.
    
2. 단건 조회 (`GET /scenarios/{scenarioId}`)
    - 특정 시나리오의 알림 정보를 반환.
    - 존재하지 않으면 null 반환. (삭제된 경우를 의미)
    - 단건 조회에서는 ETag를 다루지 않음.
        - 이유: 부분 업데이트 요청 시 전체 ETag를 덮어쓰면 동기화에 문제
    - 따라서 단건 조회 후 클라이언트 저장소는 최신이어도, 전체 조회 시점에는 ETag가 다르므로 서버가 전체 목록을 갱신해주게 됩니다.

Redis에는 2가지 키를 사용합니다.
1. `notif:etag:{memberId}` → **ETag 캐시 (String)**
2. `notif:{memberId}` → **시나리오 알림 목록 캐시 (Hash)**
- TTL은 **30일**로 설정했습니다.
- 캐시 상태별 동작:
    - 조회한 적 없음 / TTL 만료 → ETag와 목록 모두 없음 → DB 재조회
    - 알림 목록이 비어있음 → ETag만 있고 목록은 빈 리스트
    - 알림 목록이 있음 → 두 키 모두 존재

Redis 갱신은 **시나리오의 알림 관련 CRUD 이벤트**에 맞춰 EventListener에서 처리합니다.
1. 알림 있는 시나리오 생성 → Redis 추가
2. 알림 있는 → 알림 없는 수정 → Redis 삭제
3. 알림 없는 → 알림 있는 수정 → Redis 추가
4. 알림 있는 → 알림 있는 수정 → Redis 삭제 후 추가 (덮어 씌우기로 수정 예정)
5. 알림 있는 시나리오 삭제 → Redis 삭제
- `@TransactionalEventListener` → DB 트랜잭션이 완료된 후 실행 보장
- `@Async` → 비동기로 실행 (메인 트랜잭션 의존성 최소화)
- Redis 업데이트 실패 시 CRUD 트랜잭션은 그대로 성공 → 대신 Redis 캐시는 삭제하여, 다음 조회 시 DB에서 다시 채우도록 유도

---
시나리오 알림을 JPA 엔티티로 조회하면 NotificationCondition(Time/Location)을 가져오는 과정에서 N+1 문제가 발생합니다. QueryDSL을 사용하려 했으나 빌드 설정 변경과 스타일·테스트 충돌 이슈가 있어, 우선 커스텀 쿼리로 Time 조건을 일괄 조회하도록 구현했습니다. 추후 Location 기능이 추가되면 QueryDSL로 리팩토링하면 될 거 같습니다!

알림받기를 비동의한 사용자의 처리는 생각해봐야할거같습니다.
- 클라이언트 단에서 알림이 있는 시나리오 생성을 막는 1차 방어
-  서버 CRUD 레벨에서도 차단하는 2차 방어 필요
- 중간에 비활성화된 경우 Redis 캐시 삭제?

