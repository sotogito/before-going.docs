- **기상청 단기예보(동네예보)**: 일 8회, **02시부터 3시간 간격(02, 05, 08, 11, 14, 17, 20, 23 KST)**로 발표됩니다. 4시간마다보단 **3시간 주기**에 맞추거나, 최소한 3시간+지연 버퍼로 잡는 게 안전합니다. [데이터.gov](https://www.data.go.kr/data/15043494/fileData.do?utm_source=chatgpt.com)
    
- **기상청 생활기상지수(자외선 등)**: 화면/문서 기준 **3시간 단위 시각(03, 06, 09, 12, 15, 18, 21, 24)** 제공입니다. 실서비스도 이 그리드에 맞춰 나옵니다. [기상청](https://www.weather.go.kr/w/theme/daily-life/life-weather-index.do?utm_source=chatgpt.com)[기상자료개방포털](https://data.kma.go.kr/data/lwi/lwiRltmList.do?pgmNo=635&tabNo=2&utm_source=chatgpt.com)
    
- **에어코리아 미세먼지 경보**: 주의보/경보는 **발령 이벤트성(수시)**입니다. 고정 4시간 폴링보다 **짧은 주기(예: 30분~1시간)**가 권장됩니다. [데이터.gov+1](https://www.data.go.kr/data/15073885/openapi.do?utm_source=chatgpt.com)


### 타임라인
00:00~04:00 | 04:00~08:00 | 08:00~12:00 | 12:00~16:00 | 16:00~20:00 | 20:00~24:00

## 사용할 공공데이터 API

### 1. 🌧️ 기상청 단기예보 API

- URL: https://apis.data.go.kr/1360000/VilageFcstInfoService_2.0/getVilageFcst

- 갱신주기: 3시간마다 (02, 05, 08, 11, 14, 17, 20, 23시)

- 위치형식: 격자좌표 (nx, ny)

- 제공데이터: 강수형태(PTY) 코드 → 비, 비+눈, 눈, 소나기

### 2. 🌫️ 한국환경공단 에어코리아 미세먼지 API

- URL: https://apis.data.go.kr/B552584/ArpltnInforInqireSvc/getCtprvnRltmMesureDnsty

- 갱신주기: 실시간 (1시간마다)

- 위치형식: 측정소명 또는 시도명

- 제공데이터: PM10/PM2.5 농도 → 좋음, 보통, 나쁨, 매우나쁨

### 3. ☀️ 기상청 생활기상지수 API (자외선)

- URL: https://apis.data.go.kr/1360000/LivingWthrIdxServiceV4/getUVIdxV4

- 갱신주기: 3시간마다 (03, 06, 09, 12, 15, 18, 21, 24시)

- 위치형식: 지역코드 (areaNo)

- 제공데이터: 자외선지수 → 매우낮음, 낮음, 보통, 높음, 매우높음
---
### 00~04
기상청 단기예보: 
  - 발표시점: 23:00(전날)
  - 수집시간: 00, 01, 02, 03시 예보
  - 선택기준: 최악 날씨

자외선 지수:
  - 수집시간: 00시, 03시 
  - 선택기준: 최고값 (야간이므로 대부분 0)

미세먼지:
  - 수집시간: 00~03시 실시간 측정
  - 선택기준: 최악 농도

### 04~08
기상청 단기예보:
  - 발표시점: 02:00
  - 수집시간: 04, 05, 06, 07시 예보
  - 선택기준: 최악 날씨

자외선 지수:
  - 수집시간: 03시, 06시
  - 선택기준: 최고값

미세먼지:
  - 수집시간: 04~07시 실시간 측정
  - 선택기준: 최악 농도

#### 08~12
기상청 단기예보:
  - 발표시점: 05:00
  - 수집시간: 08, 09, 10, 11시 예보
  - 선택기준: 최악 날씨

자외선 지수:
  - 수집시간: 09시, 12시
  - 선택기준: 최고값

미세먼지:
  - 수집시간: 08~11시 실시간 측정
  - 선택기준: 최악 농도

#### 12~16
기상청 단기예보:
  - 발표시점: 08:00
  - 수집시간: 12, 13, 14, 15시 예보
  - 선택기준: 최악 날씨

자외선 지수:
  - 수집시간: 12시, 15시
  - 선택기준: 최고값

미세먼지:
  - 수집시간: 12~15시 실시간 측정
  - 선택기준: 최악 농도

#### 16~20
기상청 단기예보:
  - 발표시점: 11:00
  - 수집시간: 16, 17, 18, 19시 예보
  - 선택기준: 최악 날씨

자외선 지수:
  - 수집시간: 15시, 18시
  - 선택기준: 최고값

미세먼지:
  - 수집시간: 16~19시 실시간 측정
  - 선택기준: 최악 농도

### 20~24
기상청 단기예보:
  - 발표시점: 14:00
  - 수집시간: 20, 21, 22, 23시 예보
  - 선택기준: 최악 날씨

자외선 지수:
  - 수집시간: 18시, 21시
  - 선택기준: 최고값

미세먼지:
  - 수집시간: 20~23시 실시간 측정
  - 선택기준: 최악 농도


// 강남구 역삼동 일대 (5km x 5km 격자 내)
사용자 A: 37.5665, 126.9780 → 격자(60, 127), 측정소(강남구), 지역(1100000000)
사용자 B: 37.5664, 126.9781 → 격자(60, 127), 측정소(강남구), 지역(1100000000) 
사용자 C: 37.5610, 126.9850 → 격자(60, 127), 측정소(강남구), 지역(1100000000)

좌표 → 가장 가까운 측정소(stationName) 찾기 → 그 이름을 API에 넣어 요청
- 날씨(격자) = **(nx, ny)** 계산 필요
    
- 미세먼지 = **측정소(stationName)** 필요 → 좌표→TM→근접 측정소 API로 찾음
    
- 자외선 = **지역코드(areaNo)** 필요 → 미리 배포된 **코드표**를 DB에 넣어 매핑

맞아요. “하나의 위치 토큰”으로 재사용 판단하고 싶다면 **DFS 격자(nx, ny)를 공통 기준**으로 잡으면 됩니다. 이유와 설계는 이렇게 가면 깔끔해요.

# 왜 격자(nx, ny)가 좋나

- 날씨는 원래 격자 단위(≈5km)라 **정확히 일치**.
    
- 미세먼지(측정소)는 격자마다 **가장 가까운 측정소**가 보통 고정됩니다(경계 근처만 예외).
    
- 자외선은 areaNo(시·군·구/광역 단위)라 격자 여러 개가 **같은 areaNo**로 묶임 → 상위로 포괄 가능.

---

1. **위도·경도 획득**(권한 없으면 기본값 서울)
    
2. **격자(nx,ny) 계산**
    
3. **공통 타일 캐시 조회**: `tile:{nx}:{ny}`
    
    - 있으면 파생값(측정소, areaNo)도 여기서 꺼냄
        
4. **날씨 캐시 조회** → 없으면 (nx,ny + 발표시각)으로 호출
    
5. **측정소명 캐시 조회** (`tile:{nx}:{ny}:stationName`)
    
    - 없으면 lat/lon→TM→근접 측정소 API → **측정소명 캐시** → 미세먼지 API 호출
        
6. **지역코드(areaNo) 캐시 조회** (`tile:{nx}:{ny}:areaNo`)
    
    - 없으면 역지오코딩/매핑 테이블로 areaNo 결정 → **areaNo 캐시** → UV API 호출
        
7. **각 결과를 캐시에 저장**
    
    - `weather:{baseDate}:{baseTime}:{nx}:{ny}`
        
    - `pm:{stationName}:{yyyyMMddHH}`
        
    - `uv:{areaNo}:{yyyyMMddHH}`
        
    - 그리고 `tile:{nx}:{ny}` 아래 **파생값/최근 스냅샷** 업데이트
        
8. **최신 스냅샷 묶어서 반환**
    

### 포인트

- **파생값(측정소명, areaNo)을 먼저 캐시에서 찾고**, 없을 때만 계산/조회 → 다음부터는 5·6단계가 거의 스킵됩니다.
    
- **동시에 호출** 가능: (nx,ny) 확정 후, 날씨/PM/UV는 각 캐시 미스 시 **병렬**로 때려도 OK.
    
- **TTL**
    
    - 날씨: 다음 발표까지(+버퍼)
        
    - PM: 1시간(또는 30분)
        
    - UV: 3시간 단위(+버퍼)
        
    - 파생값(측정소/areaNo): 길게(일~영구)
        
- **히스테리시스**: 격자 경계 200m 이내 흔들림에는 타일 변경 보류.
    
- **권한 거부/실패 시**: `tile:{서울중심}`로 폴백.
---
요지는 이거예요:

- **날씨**는 격자(nx,ny)+발표시각(기상청 baseDate/baseTime)만 있으면 끝.
    
- **미세먼지**는 “격자+날짜”로 못 가져옵니다. **측정소명(stationName)**을 반드시 넣어야 함.
    
- **UV**도 “격자+날짜”로 못 가져옵니다. **지역코드(areaNo)**를 넣어야 함.
    

그래서 제가 말한 “있으면 파생값(측정소, areaNo)도 여기서 꺼냄”은,

- `tile:{nx}:{ny}` 캐시에 **그 격자에 대응하는 stationName, areaNo를 미리 저장해두고**, 다음 요청부터는 **그걸 그대로 꺼내서** 각 API에 쓰자는 뜻이에요.
    
- 즉 “날씨 응답의 날짜”를 재활용하자는 게 아니라, **미세먼지/UV가 요구하는 ‘ID(측정소/지역코드)’를 재활용**하자는 말입니다.

## **위치 매핑 데이터** (오래가는 데이터)

- **Key 예시:** `tile:{nx}:{ny}:meta`
    
- **Value:** `{ stationName: "강남구", areaNo: "1100000000" }`
    
- 이건 (lat,lon → nx,ny) 계산 후 **1번만** 만들어두면 이후 계속 재사용 가능.
    
- 변하지 않으니 TTL을 길게(며칠~영구) 줘도 됩니다.
    

---

## 2. **실제 관측/예보 결과** (주기적으로 바뀌는 데이터)

- **날씨 (기상청 단기예보)**
    
    - Key: `weather:{baseDate}:{baseTime}:{nx}:{ny}`
        
    - TTL: 발표주기(3시간) + 버퍼
        
- **미세먼지 (실시간 측정소)**
    
    - Key: `pm:{stationName}:{yyyyMMddHH}`
        
    - TTL: 1시간 (혹은 30분)
        
- **자외선 (생활기상지수)**
    
    - Key: `uv:{areaNo}:{yyyyMMddHH}`